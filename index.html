<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Common Runner (Lamumu Arc.)</title>
  <style>
    body { margin:0; background:#87CEEB; overflow:hidden; font-family:sans-serif; }
    canvas { display:block; width:100vw; height:100vh; background:#87CEEB; }
    .hud { position:fixed; top:10px; left:0; right:0; text-align:center; font-size:24px; color:#fff; text-shadow:0 2px 4px rgba(0,0,0,0.5); }
    .logo { position:fixed; top:10px; left:10px; width:60px; }
    .score { position:fixed; top:10px; right:10px; font-size:22px; background:rgba(255,255,255,0.7); padding:6px 10px; border-radius:8px; }
    .hint { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); background:rgba(255,255,255,.8); padding:6px 10px; border-radius:8px; font-size:14px;}
  </style>
</head>
<body>
  <div class="hud">Common Runner <small>(Lamumu Arc.)</small></div>
  <img class="logo" src="./993CBC1B-E669-4592-ABDF-9A7AA70BD8DC.png" />
  <div class="score" id="score">Score: 0</div>
  <div class="hint" id="hint">↑ Jump • ↓ Duck • R Restart</div>
  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const hintEl  = document.getElementById('hint');
  let W, H, groundY;
  function resize(){
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    groundY = H - 100;
  }
  window.addEventListener('resize', resize);
  resize();

  // Assets
  const cowImg = new Image();
  cowImg.src = "./20250921_2312_3D Pixel Character Design_remix_01k5pyekm6e2e9e21az6gprrtb.png";

  // Player (facing right, slightly larger)
  const player = { x:90, y:0, vy:0, width:100, height:100, frame:0, frameTick:0, ducking:false,
    jump(){ if(this.y<=0){ this.vy=16; this.y=1; } },
    update(dt){
      if(this.y>0 || this.vy>0){ this.vy -= 0.8; this.y += this.vy; if(this.y<0){ this.y=0; this.vy=0; } }
      this.frameTick += dt; if(this.frameTick>100){ this.frame=(this.frame+1)%2; this.frameTick=0; }
    },
    draw(ctx){
      let scale = 0.9 + (this.frame*0.05);
      let h = this.height*scale;
      let w = this.width*scale;
      const x = this.x, y = groundY-h-this.y;
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.scale(-1, 1); // face right
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(cowImg, -w/2, -h/2, w, h);
      ctx.restore();
      // shadow
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.ellipse(x + w*0.5, groundY + 6, 40, 10, 0, 0, Math.PI*2);
      ctx.fillStyle = "#000"; ctx.fill();
      ctx.globalAlpha = 1;
    },
    hitbox(){
      return {x:this.x+6, y:groundY-this.height-this.y+4, w:this.width-12, h:this.height-8}; // tighter player box
    }
  };

  // Obstacles
  let obstacles=[], obstacleTimer=0;
  function spawnObstacle(){
    const h = 40+Math.random()*40;
    const w = 44+Math.random()*20;
    obstacles.push({x:W, y:groundY-h, w, h});
  }

  // Simple parallax trees (as in v5)
  const trees=[];
  function spawnTree(){ trees.push({x:W, y:groundY-120, h:100+Math.random()*80}); }
  let treeTimer=0;

  // Game state
  let last=0, score=0, gameOver=false;
  let speed = 6.5;          // start speed
  const maxSpeed = 14;      // cap like dino does at high pace

  // Restart
  function restart(){
    obstacles.length=0;
    trees.length=0;
    obstacleTimer = 0; treeTimer=0;
    score=0; speed=6.5; last=0; gameOver=false;
    player.y=0; player.vy=0; player.ducking=false;
    hintEl.textContent = "↑ Jump • ↓ Duck • R Restart";
    requestAnimationFrame(loop);
  }
  window.addEventListener('keydown',e=>{
    if(e.code==="ArrowUp" && !gameOver){ player.jump(); }
    if(e.code==="ArrowDown"){ player.ducking=true; }
    if(e.code==="KeyR"){ restart(); }
  });
  window.addEventListener('keyup',e=>{ if(e.code==="ArrowDown"){ player.ducking=false; } });

  function drawFence(o){
    const postW = Math.max(6, Math.floor(o.w*0.22));
    const railH = Math.max(5, Math.floor(o.h*0.16));
    ctx.fillStyle="#8B5A2B";
    ctx.fillRect(o.x, o.y, postW, o.h);
    ctx.fillRect(o.x + o.w - postW, o.y, postW, o.h);
    ctx.fillStyle="#A0522D";
    const r1y = o.y + Math.floor(o.h*0.35);
    const r2y = o.y + Math.floor(o.h*0.68);
    ctx.fillRect(o.x, r1y, o.w, railH);
    ctx.fillRect(o.x, r2y, o.w, railH);
  }

  function overlap(a,b,pad){
    // shrink obstacle box slightly to avoid unfair collisions
    const bb = {x:b.x+pad, y:b.y+pad, w:b.w-2*pad, h:b.h-2*pad};
    return !(a.x+a.w<bb.x || a.x>bb.x+bb.w || a.y+a.h<bb.y || a.y>bb.y+bb.h);
  }

  function loop(ts){
    const dt = Math.min(34, ts - last || 16); last = ts;
    ctx.clearRect(0,0,W,H);

    // Background
    ctx.fillStyle="#87CEEB"; ctx.fillRect(0,0,W,H);
    // trees
    treeTimer -= dt;
    if(treeTimer<=0){ spawnTree(); treeTimer = 2200 + Math.random()*1200; }
    ctx.fillStyle="#228B22";
    for(let i=trees.length-1;i>=0;i--){
      let t=trees[i]; t.x -= 2;
      ctx.fillRect(t.x, t.y-t.h, 40, t.h);
      if(t.x+40<0) trees.splice(i,1);
    }
    // ground
    ctx.fillStyle="#228B22"; ctx.fillRect(0,groundY,W,H-groundY);

    // Obstacles spawning, paced by speed like Dino
    obstacleTimer -= dt;
    if(obstacleTimer<=0){
      spawnObstacle();
      // distance-based spacing to avoid unavoidable combos
      const minGap = 520 - speed*20;  // pixels of travel
      const maxGap = 820 - speed*30;
      const ms = (Math.random()*(maxGap-minGap)+minGap) / (speed*60); // convert distance to seconds at current speed
      obstacleTimer = ms*1000;
    }

    // Update obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      let o=obstacles[i];
      o.x -= speed;
      drawFence(o);
      if(o.x+o.w<0) obstacles.splice(i,1);
    }

    // Player
    player.update(dt);
    player.draw(ctx);

    // Collisions with padding for fairness
    const hb = player.hitbox();
    for(const o of obstacles){
      if(overlap(hb, o, 6)){ gameOver=true; break; }
    }

    // Score & progressive speed-up (Dino-like: gentle continuous increase)
    if(!gameOver){
      score += dt * 0.06;                         // ~3.6 pts/sec
      // speed rises slowly with score; harder very gradually
      const target = Math.min(maxSpeed, 6.5 + Math.floor(score/100)*0.4);
      // ease towards target
      speed += (target - speed) * 0.02;
      scoreEl.textContent = "Score: " + Math.floor(score);
      hintEl.textContent = "";
      requestAnimationFrame(loop);
    } else {
      ctx.fillStyle="rgba(0,0,0,0.55)"; ctx.fillRect(0,0,W,H);
      ctx.fillStyle="#fff"; ctx.textAlign="center";
      ctx.font="bold 32px Arial"; ctx.fillText("Game Over", W/2, H/2 - 10);
      ctx.font="18px Arial"; ctx.fillText("Press R to Restart", W/2, H/2 + 26);
    }
  }

  cowImg.onload=()=>requestAnimationFrame(loop);
})();
</script>
</body>
</html>
